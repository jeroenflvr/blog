<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>The Generalist&apos;s Plex</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    <!-- mathtex -->
    <link type="text/css" rel="stylesheet" href="/Temml-Local.css">
    <script defer src="/temml.min.js"></script>
    <script defer src="/render-mathtex.js"></script>
    <!-- /mathtex -->
    
  <style>
    #prev-next {
     display: flex;
     flex-direction: row;
     justify-content: space-between;
     margin-top: 40px;
    }

    figure {
      align-self: center;
      text-align: center;
      font-style: italic;
    }

    .post {
      display:flex;
      flex-direction: column;
    }
  </style>

  </head>
  <body id="body">
    <h1 class="site-title">The Generalist&apos;s Plex</h1>
    <nav>
      <a href="/">Home</a>
       &nbsp; • &nbsp;
      <a href="/about/">About</a>
       &nbsp; • &nbsp;
      <a href="/blog/">Blog</a>
      
         &nbsp; • &nbsp;
        <a href="/devlog/1990/">Devlog</a>
      
    </nav>
    
  <h1>Rust Optimizations</h1>
  <div class="post"><h1>Squeezing Every Nanosecond: Optimizing Branch Prediction and Cache Performance in Rust</h1><p>When building high-performance systems in Rust, understanding how your code interacts with modern CPU architectures can mean the difference between “fast enough” and “blazingly fast.” Two of the most critical factors affecting performance are branch prediction and cache behavior—areas where even small optimizations can yield significant speedups.</p><p>Modern CPUs are marvels of engineering, executing billions of instructions per second through sophisticated techniques like speculative execution, out-of-order processing, and multi-level caching. However, these optimizations come with a caveat: they work best when your code follows predictable patterns that the hardware can anticipate.</p><p>In this deep dive, we’ll explore how to write Rust code that works harmoniously with your CPU’s branch predictor and cache hierarchy. We’ll cover practical techniques, provide real benchmarks, and show you how to measure the impact of your optimizations.</p><h2>Understanding the Hardware: Why This Matters</h2><p>Before diving into techniques, let’s establish why branch prediction and cache performance are crucial:</p><p><strong>Branch Prediction</strong>: Modern CPUs speculatively execute instructions before knowing if a branch will be taken. When the prediction is wrong, the CPU must discard work and restart—a costly operation that can stall execution for dozens of cycles.</p><p><strong>Cache Performance</strong>: Memory access patterns determine whether your data lives in fast CPU caches (L1/L2/L3) or slow main memory. Cache misses can be 100-300x slower than cache hits, making memory layout optimization critical for performance.</p><h2>Branch Prediction Optimization</h2><h3>Technique 1: Providing Hints to the Compiler</h3><p>Rust provides intrinsics to hint at branch likelihood, helping the compiler generate better code:</p><pre><code class="rust"><span class="keyword">use</span> <span class="constructor constant type">std</span><span class="punctuation_delimiter">::</span><span class="constructor constant">intrinsics</span><span class="punctuation_delimiter">::</span><span class="punctuation_bracket">{</span><span class="constructor constant">likely</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">unlikely</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

<span class="keyword">fn</span> <span class="constructor constant function">process_data</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">data</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type_builtin">i32</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span> -&gt; <span class="type_builtin">i32</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">sum</span> = <span class="constant_builtin">0</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">for</span> <span class="operator">&amp;</span><span class="constructor constant">value</span> <span class="keyword">in</span> <span class="constructor constant">data</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">if</span> <span class="constructor constant function">likely</span><span class="punctuation_bracket">(</span><span class="constructor constant">value</span> &gt; <span class="constant_builtin">0</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">sum</span> += <span class="constructor constant">value</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="constructor constant function">unlikely</span><span class="punctuation_bracket">(</span><span class="constructor constant">value</span> &lt; -<span class="constant_builtin">1000</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="comment">// Rare error case</span>
            <span class="constructor function_macro constant">eprintln</span><span class="function_macro">!</span><span class="punctuation_bracket">(</span><span class="string">&quot;Unexpected negative value: {}&quot;</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">value</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="constructor constant">sum</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h3>Technique 2: Eliminating Branches with Branchless Code</h3><p>Sometimes the best branch is no branch at all:</p><pre><code class="rust"><span class="comment">// Branchy version</span>
<span class="keyword">fn</span> <span class="constructor constant function">clamp_positive_branchy</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">x</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> -&gt; <span class="type_builtin">i32</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">if</span> <span class="constructor constant">x</span> &gt; <span class="constant_builtin">0</span> <span class="punctuation_bracket">{</span> <span class="constructor constant">x</span> <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span> <span class="constant_builtin">0</span> <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Branchless version</span>
<span class="keyword">fn</span> <span class="constructor constant function">clamp_positive_branchless</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">x</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> -&gt; <span class="type_builtin">i32</span> <span class="punctuation_bracket">{</span>
    <span class="constructor constant">x</span><span class="punctuation_delimiter">.</span><span class="property function_method">max</span><span class="punctuation_bracket">(</span><span class="constant_builtin">0</span><span class="punctuation_bracket">)</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Or for more complex conditions</span>
<span class="keyword">fn</span> <span class="constructor constant function">select_branchless</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">condition</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">bool</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">a</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">b</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> -&gt; <span class="type_builtin">i32</span> <span class="punctuation_bracket">{</span>
    <span class="comment">// Compiler often optimizes this to conditional moves</span>
    <span class="keyword">if</span> <span class="constructor constant">condition</span> <span class="punctuation_bracket">{</span> <span class="constructor constant">a</span> <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span> <span class="constructor constant">b</span> <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h3>Technique 3: Restructuring Control Flow</h3><p>Replace unpredictable branches with more predictable patterns:</p><pre><code class="rust"><span class="comment">// Poor branch prediction due to random-looking pattern</span>
<span class="keyword">fn</span> <span class="constructor constant function">process_mixed_data_bad</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">data</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type_builtin">i32</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span> -&gt; <span class="punctuation_bracket">(</span><span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">positive_sum</span> = <span class="constant_builtin">0</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">negative_sum</span> = <span class="constant_builtin">0</span><span class="punctuation_delimiter">;</span>
    
    <span class="keyword">for</span> <span class="operator">&amp;</span><span class="constructor constant">value</span> <span class="keyword">in</span> <span class="constructor constant">data</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">if</span> <span class="constructor constant">value</span> &gt; <span class="constant_builtin">0</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">positive_sum</span> += <span class="constructor constant">value</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">negative_sum</span> += <span class="constructor constant">value</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">(</span><span class="constructor constant">positive_sum</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">negative_sum</span><span class="punctuation_bracket">)</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Better: separate the data first, then process</span>
<span class="keyword">fn</span> <span class="constructor constant function">process_mixed_data_good</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">data</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type_builtin">i32</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span> -&gt; <span class="punctuation_bracket">(</span><span class="type_builtin">i32</span><span class="punctuation_delimiter">,</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="constructor constant">positive_sum</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> = <span class="constructor constant">data</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">filter</span><span class="punctuation_bracket">(</span>|<span class="operator">&amp;</span><span class="operator">&amp;</span><span class="constructor constant">x</span>| <span class="constructor constant">x</span> &gt; <span class="constant_builtin">0</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">sum</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">let</span> <span class="constructor constant">negative_sum</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> = <span class="constructor constant">data</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">filter</span><span class="punctuation_bracket">(</span>|<span class="operator">&amp;</span><span class="operator">&amp;</span><span class="constructor constant">x</span>| <span class="constructor constant">x</span> &lt;= <span class="constant_builtin">0</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">sum</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">(</span><span class="constructor constant">positive_sum</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">negative_sum</span><span class="punctuation_bracket">)</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h2>Cache Optimization Strategies</h2><h3>Structure of Arrays vs Array of Structures</h3><p>One of the most impactful optimizations involves reorganizing your data layout:</p><pre><code class="rust"><span class="comment">// Array of Structures (AoS) - poor cache locality</span>
<span class="attribute">#</span><span class="punctuation_bracket attribute">[</span><span class="constructor constant attribute">derive</span><span class="punctuation_bracket attribute">(</span><span class="constructor constant attribute">Clone</span><span class="punctuation_bracket attribute">)</span><span class="punctuation_bracket attribute">]</span>
<span class="keyword">struct</span> <span class="type">ParticleAoS</span> <span class="punctuation_bracket">{</span>
    <span class="property">position</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="type_builtin">f32</span><span class="punctuation_delimiter">;</span> <span class="constant_builtin">3</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span>
    <span class="property">velocity</span><span class="punctuation_delimiter">:</span> <span class="punctuation_bracket">[</span><span class="type_builtin">f32</span><span class="punctuation_delimiter">;</span> <span class="constant_builtin">3</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span>
    <span class="property">mass</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span><span class="punctuation_delimiter">,</span>
    <span class="property">charge</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>

<span class="keyword">fn</span> <span class="constructor constant function">update_positions_aos</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">particles</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="punctuation_bracket">[</span><span class="type">ParticleAoS</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">dt</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">for</span> <span class="constructor constant">particle</span> <span class="keyword">in</span> <span class="constructor constant">particles</span> <span class="punctuation_bracket">{</span>
        <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">position</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">velocity</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
        <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">position</span><span class="punctuation_bracket">[</span><span class="constant_builtin">1</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">velocity</span><span class="punctuation_bracket">[</span><span class="constant_builtin">1</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
        <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">position</span><span class="punctuation_bracket">[</span><span class="constant_builtin">2</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">particle</span><span class="punctuation_delimiter">.</span><span class="property">velocity</span><span class="punctuation_bracket">[</span><span class="constant_builtin">2</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Structure of Arrays (SoA) - better cache locality</span>
<span class="keyword">struct</span> <span class="type">ParticlesSoA</span> <span class="punctuation_bracket">{</span>
    <span class="property">positions</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span>[<span class="type_builtin">f32</span><span class="punctuation_delimiter">;</span> <span class="constant_builtin">3</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_delimiter">,</span>
    <span class="property">velocities</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span>[<span class="type_builtin">f32</span><span class="punctuation_delimiter">;</span> <span class="constant_builtin">3</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_delimiter">,</span>
    <span class="property">masses</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_delimiter">,</span>
    <span class="property">charges</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_delimiter">,</span>
<span class="punctuation_bracket">}</span>

<span class="keyword">impl</span> <span class="type">ParticlesSoA</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">fn</span> <span class="constructor constant function">update_positions</span><span class="punctuation_bracket">(</span><span class="operator">&amp;</span><span class="keyword">mut</span> <span class="variable_builtin">self</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">dt</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">f32</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">for</span> <span class="punctuation_bracket">(</span><span class="constructor constant">pos</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">vel</span><span class="punctuation_bracket">)</span> <span class="keyword">in</span> <span class="variable_builtin">self</span><span class="punctuation_delimiter">.</span><span class="property">positions</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter_mut</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">zip</span><span class="punctuation_bracket">(</span><span class="operator">&amp;</span><span class="variable_builtin">self</span><span class="punctuation_delimiter">.</span><span class="property">velocities</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">pos</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">vel</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
            <span class="constructor constant">pos</span><span class="punctuation_bracket">[</span><span class="constant_builtin">1</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">vel</span><span class="punctuation_bracket">[</span><span class="constant_builtin">1</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
            <span class="constructor constant">pos</span><span class="punctuation_bracket">[</span><span class="constant_builtin">2</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">vel</span><span class="punctuation_bracket">[</span><span class="constant_builtin">2</span><span class="punctuation_bracket">]</span> <span class="operator">*</span> <span class="constructor constant">dt</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h3>Memory Layout Optimization</h3><p>Careful struct design can significantly impact cache performance:</p><pre><code class="rust"><span class="comment">// Poor layout - lots of padding</span>
<span class="keyword">struct</span> <span class="type">BadLayout</span> <span class="punctuation_bracket">{</span>
    <span class="property">flag</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">bool</span><span class="punctuation_delimiter">,</span>     <span class="comment">// 1 byte</span>
    <span class="comment">// 7 bytes padding</span>
    <span class="property">big_num</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>   <span class="comment">// 8 bytes</span>
    <span class="property">small_num</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_delimiter">,</span> <span class="comment">// 2 bytes</span>
    <span class="comment">// 6 bytes padding</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Better layout - minimal padding</span>
<span class="attribute">#</span><span class="punctuation_bracket attribute">[</span><span class="constructor constant attribute">repr</span><span class="punctuation_bracket attribute">(</span><span class="constructor constant attribute">C</span><span class="punctuation_bracket attribute">)</span><span class="punctuation_bracket attribute">]</span>
<span class="keyword">struct</span> <span class="type">GoodLayout</span> <span class="punctuation_bracket">{</span>
    <span class="property">big_num</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u64</span><span class="punctuation_delimiter">,</span>   <span class="comment">// 8 bytes</span>
    <span class="property">small_num</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u16</span><span class="punctuation_delimiter">,</span> <span class="comment">// 2 bytes</span>
    <span class="property">flag</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">bool</span><span class="punctuation_delimiter">,</span>     <span class="comment">// 1 byte</span>
    <span class="comment">// 5 bytes padding (unavoidable due to alignment)</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h3>Cache-Friendly Algorithms</h3><p>Process data in patterns that maximize cache reuse:</p><pre><code class="rust"><span class="comment">// Cache-unfriendly: column-major access of row-major data</span>
<span class="keyword">fn</span> <span class="constructor constant function">sum_columns_bad</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">matrix</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span> -&gt; <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="constructor constant">cols</span> = <span class="constructor constant">matrix</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">.</span><span class="property function_method">len</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">sums</span> = <span class="constructor function_macro constant">vec</span><span class="function_macro">!</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0.0</span><span class="punctuation_delimiter">;</span> <span class="constructor constant">cols</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>
    
    <span class="keyword">for</span> <span class="constructor constant">col</span> <span class="keyword">in</span> <span class="constant_builtin">0</span>..<span class="constructor constant">cols</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">for</span> <span class="constructor constant">row</span> <span class="keyword">in</span> <span class="constructor constant">matrix</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">sums</span><span class="punctuation_bracket">[</span><span class="constructor constant">col</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">row</span><span class="punctuation_bracket">[</span><span class="constructor constant">col</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span> <span class="comment">// Poor cache locality</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="constructor constant">sums</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Cache-friendly: row-major access</span>
<span class="keyword">fn</span> <span class="constructor constant function">sum_columns_good</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">matrix</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">)</span> -&gt; <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">f32</span><span class="punctuation_bracket">&gt;</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="constructor constant">cols</span> = <span class="constructor constant">matrix</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">.</span><span class="property function_method">len</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">sums</span> = <span class="constructor function_macro constant">vec</span><span class="function_macro">!</span><span class="punctuation_bracket">[</span><span class="constant_builtin">0.0</span><span class="punctuation_delimiter">;</span> <span class="constructor constant">cols</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>
    
    <span class="keyword">for</span> <span class="constructor constant">row</span> <span class="keyword">in</span> <span class="constructor constant">matrix</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">for</span> <span class="punctuation_bracket">(</span><span class="constructor constant">col</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constructor constant">value</span><span class="punctuation_bracket">)</span> <span class="keyword">in</span> <span class="constructor constant">row</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">enumerate</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
            <span class="constructor constant">sums</span><span class="punctuation_bracket">[</span><span class="constructor constant">col</span><span class="punctuation_bracket">]</span> += <span class="constructor constant">value</span><span class="punctuation_delimiter">;</span> <span class="comment">// Better cache locality</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    <span class="constructor constant">sums</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h2>Benchmarking and Profiling</h2><h3>Setting Up Benchmarks</h3><p>Here’s how to measure the impact of your optimizations using the <code>criterion</code> crate:</p><pre><code class="rust"><span class="comment">// Cargo.toml</span>
<span class="punctuation_bracket">[</span><span class="constructor constant">dev</span>-<span class="constructor constant">dependencies</span><span class="punctuation_bracket">]</span>
<span class="constructor constant">criterion</span> = <span class="string">&quot;0.5&quot;</span>

<span class="punctuation_bracket">[</span><span class="punctuation_bracket">[</span><span class="constructor constant">bench</span><span class="punctuation_bracket">]</span><span class="punctuation_bracket">]</span>
<span class="constructor constant">name</span> = <span class="string">&quot;branch_prediction&quot;</span>
<span class="constructor constant">harness</span> = <span class="constant_builtin">false</span>
</code></pre>
<pre><code class="rust"><span class="comment">// benches/branch_prediction.rs</span>
<span class="keyword">use</span> <span class="constructor constant">criterion</span><span class="punctuation_delimiter">::</span><span class="punctuation_bracket">{</span><span class="constructor constant">black_box</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">criterion_group</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">criterion_main</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">Criterion</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

<span class="keyword">fn</span> <span class="constructor constant function">benchmark_branch_prediction</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">c</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="type">Criterion</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="constructor constant">data</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">i32</span><span class="punctuation_bracket">&gt;</span> = <span class="punctuation_bracket">(</span><span class="constant_builtin">0</span>..<span class="constant_builtin">10000</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">map</span><span class="punctuation_bracket">(</span>|<span class="constructor constant">i</span>| <span class="keyword">if</span> <span class="constructor constant">i</span> % <span class="constant_builtin">3</span> == <span class="constant_builtin">0</span> <span class="punctuation_bracket">{</span> -<span class="constructor constant">i</span> <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span> <span class="constructor constant">i</span> <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">collect</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    
    <span class="constructor constant">c</span><span class="punctuation_delimiter">.</span><span class="property function_method">bench_function</span><span class="punctuation_bracket">(</span><span class="string">&quot;branchy_clamp&quot;</span><span class="punctuation_delimiter">,</span> |<span class="constructor constant">b</span>| <span class="punctuation_bracket">{</span>
        <span class="constructor constant">b</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span>|| <span class="punctuation_bracket">{</span>
            <span class="keyword">let</span> <span class="constructor constant">sum</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> = <span class="constructor constant">data</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span>
                <span class="punctuation_delimiter">.</span><span class="property function_method">map</span><span class="punctuation_bracket">(</span>|<span class="operator">&amp;</span><span class="constructor constant">x</span>| <span class="keyword">if</span> <span class="constructor constant">x</span> &gt; <span class="constant_builtin">0</span> <span class="punctuation_bracket">{</span> <span class="constructor constant">x</span> <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span> <span class="constant_builtin">0</span> <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span>
                <span class="punctuation_delimiter">.</span><span class="property function_method">sum</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="constructor constant function">black_box</span><span class="punctuation_bracket">(</span><span class="constructor constant">sum</span><span class="punctuation_bracket">)</span>
        <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span>
    <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    
    <span class="constructor constant">c</span><span class="punctuation_delimiter">.</span><span class="property function_method">bench_function</span><span class="punctuation_bracket">(</span><span class="string">&quot;branchless_clamp&quot;</span><span class="punctuation_delimiter">,</span> |<span class="constructor constant">b</span>| <span class="punctuation_bracket">{</span>
        <span class="constructor constant">b</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span>|| <span class="punctuation_bracket">{</span>
            <span class="keyword">let</span> <span class="constructor constant">sum</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> = <span class="constructor constant">data</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span>
                <span class="punctuation_delimiter">.</span><span class="property function_method">map</span><span class="punctuation_bracket">(</span>|<span class="operator">&amp;</span><span class="constructor constant">x</span>| <span class="constructor constant">x</span><span class="punctuation_delimiter">.</span><span class="property function_method">max</span><span class="punctuation_bracket">(</span><span class="constant_builtin">0</span><span class="punctuation_bracket">)</span><span class="punctuation_bracket">)</span>
                <span class="punctuation_delimiter">.</span><span class="property function_method">sum</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="constructor constant function">black_box</span><span class="punctuation_bracket">(</span><span class="constructor constant">sum</span><span class="punctuation_bracket">)</span>
        <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span>
    <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="constructor function_macro constant">criterion_group</span><span class="function_macro">!</span><span class="punctuation_bracket">(</span><span class="constructor constant">benches</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">benchmark_branch_prediction</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="constructor function_macro constant">criterion_main</span><span class="function_macro">!</span><span class="punctuation_bracket">(</span><span class="constructor constant">benches</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<h3>Cache Performance Benchmarks</h3><pre><code class="rust"><span class="comment">// benches/cache_performance.rs</span>
<span class="keyword">use</span> <span class="constructor constant">criterion</span><span class="punctuation_delimiter">::</span><span class="punctuation_bracket">{</span><span class="constructor constant">black_box</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">criterion_group</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">criterion_main</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">Criterion</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">BenchmarkId</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>

<span class="keyword">const</span> <span class="constructor constant">SIZES</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="type_builtin">usize</span><span class="punctuation_bracket">]</span> = <span class="operator">&amp;</span><span class="punctuation_bracket">[</span><span class="constant_builtin">1024</span><span class="punctuation_delimiter">,</span> <span class="constant_builtin">4096</span><span class="punctuation_delimiter">,</span> <span class="constant_builtin">16384</span><span class="punctuation_delimiter">,</span> <span class="constant_builtin">65536</span><span class="punctuation_delimiter">,</span> <span class="constant_builtin">262144</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>

<span class="keyword">fn</span> <span class="constructor constant function">benchmark_cache_performance</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">c</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="type">Criterion</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">group</span> = <span class="constructor constant">c</span><span class="punctuation_delimiter">.</span><span class="property function_method">benchmark_group</span><span class="punctuation_bracket">(</span><span class="string">&quot;cache_performance&quot;</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    
    <span class="keyword">for</span> <span class="operator">&amp;</span><span class="constructor constant">size</span> <span class="keyword">in</span> <span class="constructor constant">SIZES</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">let</span> <span class="constructor constant">data</span><span class="punctuation_delimiter">:</span> <span class="type">Vec</span><span class="punctuation_bracket">&lt;</span><span class="type_builtin">i32</span><span class="punctuation_bracket">&gt;</span> = <span class="punctuation_bracket">(</span><span class="constant_builtin">0</span>..<span class="constructor constant">size</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">map</span><span class="punctuation_bracket">(</span>|<span class="constructor constant">i</span>| <span class="constructor constant">i</span> <span class="keyword">as</span> <span class="type_builtin">i32</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">collect</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        
        <span class="constructor constant">group</span><span class="punctuation_delimiter">.</span><span class="property function_method">bench_with_input</span><span class="punctuation_bracket">(</span><span class="constructor constant type">BenchmarkId</span><span class="punctuation_delimiter">::</span><span class="constructor constant function">new</span><span class="punctuation_bracket">(</span><span class="string">&quot;sequential&quot;</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">size</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constructor constant">size</span><span class="punctuation_delimiter">,</span> |<span class="constructor constant">b</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constructor constant">size</span>| <span class="punctuation_bracket">{</span>
            <span class="constructor constant">b</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span>|| <span class="punctuation_bracket">{</span>
                <span class="keyword">let</span> <span class="constructor constant">sum</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">i32</span> = <span class="constructor constant">data</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">sum</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
                <span class="constructor constant function">black_box</span><span class="punctuation_bracket">(</span><span class="constructor constant">sum</span><span class="punctuation_bracket">)</span>
            <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span>
        <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        
        <span class="constructor constant">group</span><span class="punctuation_delimiter">.</span><span class="property function_method">bench_with_input</span><span class="punctuation_bracket">(</span><span class="constructor constant type">BenchmarkId</span><span class="punctuation_delimiter">::</span><span class="constructor constant function">new</span><span class="punctuation_bracket">(</span><span class="string">&quot;random&quot;</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">size</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constructor constant">size</span><span class="punctuation_delimiter">,</span> |<span class="constructor constant">b</span><span class="punctuation_delimiter">,</span> <span class="operator">&amp;</span><span class="constructor constant">size</span>| <span class="punctuation_bracket">{</span>
            <span class="keyword">use</span> <span class="constructor constant type">std</span><span class="punctuation_delimiter">::</span><span class="constructor constant type">collections</span><span class="punctuation_delimiter">::</span><span class="constructor constant type">hash_map</span><span class="punctuation_delimiter">::</span><span class="constructor constant">DefaultHasher</span><span class="punctuation_delimiter">;</span>
            <span class="keyword">use</span> <span class="constructor constant type">std</span><span class="punctuation_delimiter">::</span><span class="constructor constant">hash</span><span class="punctuation_delimiter">::</span><span class="punctuation_bracket">{</span><span class="constructor constant">Hash</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">Hasher</span><span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
            
            <span class="constructor constant">b</span><span class="punctuation_delimiter">.</span><span class="property function_method">iter</span><span class="punctuation_bracket">(</span>|| <span class="punctuation_bracket">{</span>
                <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">sum</span> = <span class="constant_builtin">0i32</span><span class="punctuation_delimiter">;</span>
                <span class="keyword">for</span> <span class="constructor constant">i</span> <span class="keyword">in</span> <span class="constant_builtin">0</span>..<span class="constructor constant">size</span> <span class="punctuation_bracket">{</span>
                    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="constructor constant">hasher</span> = <span class="constructor constant type">DefaultHasher</span><span class="punctuation_delimiter">::</span><span class="constructor constant function">new</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
                    <span class="constructor constant">i</span><span class="punctuation_delimiter">.</span><span class="property function_method">hash</span><span class="punctuation_bracket">(</span><span class="operator">&amp;</span><span class="keyword">mut</span> <span class="constructor constant">hasher</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
                    <span class="keyword">let</span> <span class="constructor constant">index</span> = <span class="punctuation_bracket">(</span><span class="constructor constant">hasher</span><span class="punctuation_delimiter">.</span><span class="property function_method">finish</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="keyword">as</span> <span class="type_builtin">usize</span><span class="punctuation_bracket">)</span> % <span class="constructor constant">size</span><span class="punctuation_delimiter">;</span>
                    <span class="constructor constant">sum</span> += <span class="constructor constant">data</span><span class="punctuation_bracket">[</span><span class="constructor constant">index</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">;</span>
                <span class="punctuation_bracket">}</span>
                <span class="constructor constant function">black_box</span><span class="punctuation_bracket">(</span><span class="constructor constant">sum</span><span class="punctuation_bracket">)</span>
            <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span>
        <span class="punctuation_bracket">}</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
    
    <span class="constructor constant">group</span><span class="punctuation_delimiter">.</span><span class="property function_method">finish</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="punctuation_bracket">}</span>

<span class="constructor function_macro constant">criterion_group</span><span class="function_macro">!</span><span class="punctuation_bracket">(</span><span class="constructor constant">benches</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">benchmark_cache_performance</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
<span class="constructor function_macro constant">criterion_main</span><span class="function_macro">!</span><span class="punctuation_bracket">(</span><span class="constructor constant">benches</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
</code></pre>
<h3>System-Level Profiling</h3><p>Use <code>perf</code> (Linux) or <code>Instruments</code> (macOS) to get detailed CPU metrics:</p><pre><code class="bash"><span class="comment"># Build with optimizations and debug info</span>
<span class="constant function">cargo</span> <span class="constant">build</span> <span class="constant">--release</span>

<span class="comment"># Profile branch prediction</span>
<span class="constant function">perf</span> <span class="constant">stat</span> <span class="constant">-e</span> <span class="constant">branches,branch-misses,branch-load-misses</span> <span class="constant">target/release/your_program</span>

<span class="comment"># Profile cache performance</span>
<span class="constant function">perf</span> <span class="constant">stat</span> <span class="constant">-e</span> <span class="constant">cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses</span> <span class="constant">target/release/your_program</span>

<span class="comment"># Get detailed per-function breakdown</span>
<span class="constant function">perf</span> <span class="constant">record</span> <span class="constant">target/release/your_program</span>
<span class="constant function">perf</span> <span class="constant">report</span>
</code></pre>
<h3>Interpreting Results</h3><p>Here’s what to look for in your profiling results:</p><ul><li><strong>Branch miss rate</strong>: Should be under 5% for well-optimized code</li><li><strong>Cache miss rate</strong>: Varies by workload, but under 10% is generally good</li><li><strong>Instructions per cycle (IPC)</strong>: Higher is better; modern CPUs can achieve 2-4 IPC</li></ul><p>Example output interpretation:</p><pre><code>Performance counter stats for &apos;./optimized_program&apos;:
        45,234,567      branches                  #  451.23 M/sec
         1,234,567      branch-misses             #    2.73% of all branches
        12,345,678      cache-references          #  123.46 M/sec
         1,234,567      cache-misses              #   10.00% of all cache refs
</code></pre><h2>Real-World Example: Optimizing a Hot Path</h2><p>Let’s put it all together with a practical example—optimizing a simple image processing function:</p><pre><code class="rust"><span class="comment">// Before optimization</span>
<span class="keyword">fn</span> <span class="constructor constant function">apply_threshold_slow</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">image</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="punctuation_bracket">[</span><span class="type_builtin">u8</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">threshold</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">for</span> <span class="constructor constant">pixel</span> <span class="keyword">in</span> <span class="constructor constant">image</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">if</span> <span class="operator">*</span><span class="constructor constant">pixel</span> &gt; <span class="constructor constant">threshold</span> <span class="punctuation_bracket">{</span>
            <span class="operator">*</span><span class="constructor constant">pixel</span> = <span class="constant_builtin">255</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span> <span class="keyword">else</span> <span class="punctuation_bracket">{</span>
            <span class="operator">*</span><span class="constructor constant">pixel</span> = <span class="constant_builtin">0</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// After optimization</span>
<span class="keyword">fn</span> <span class="constructor constant function">apply_threshold_fast</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">image</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="punctuation_bracket">[</span><span class="type_builtin">u8</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">threshold</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="comment">// Process in chunks to improve cache locality</span>
    <span class="keyword">for</span> <span class="constructor constant">chunk</span> <span class="keyword">in</span> <span class="constructor constant">image</span><span class="punctuation_delimiter">.</span><span class="property function_method">chunks_mut</span><span class="punctuation_bracket">(</span><span class="constant_builtin">64</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">for</span> <span class="constructor constant">pixel</span> <span class="keyword">in</span> <span class="constructor constant">chunk</span> <span class="punctuation_bracket">{</span>
            <span class="comment">// Branchless threshold operation</span>
            <span class="operator">*</span><span class="constructor constant">pixel</span> = <span class="punctuation_bracket">(</span><span class="punctuation_bracket">(</span><span class="operator">*</span><span class="constructor constant">pixel</span> &gt; <span class="constructor constant">threshold</span><span class="punctuation_bracket">)</span> <span class="keyword">as</span> <span class="type_builtin">u8</span><span class="punctuation_bracket">)</span> <span class="operator">*</span> <span class="constant_builtin">255</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>

<span class="comment">// Even better: using SIMD for data parallelism</span>
<span class="attribute">#</span><span class="punctuation_bracket attribute">[</span><span class="constructor constant attribute">cfg</span><span class="punctuation_bracket attribute">(</span><span class="constructor constant attribute">target_arch</span><span class="attribute"> = </span><span class="string attribute">&quot;x86_64&quot;</span><span class="punctuation_bracket attribute">)</span><span class="punctuation_bracket attribute">]</span>
<span class="keyword">fn</span> <span class="constructor constant function">apply_threshold_simd</span><span class="punctuation_bracket">(</span><span class="constructor constant variable_parameter">image</span><span class="punctuation_delimiter">:</span> <span class="operator">&amp;</span><span class="keyword">mut</span> <span class="punctuation_bracket">[</span><span class="type_builtin">u8</span><span class="punctuation_bracket">]</span><span class="punctuation_delimiter">,</span> <span class="constructor constant variable_parameter">threshold</span><span class="punctuation_delimiter">:</span> <span class="type_builtin">u8</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
    <span class="keyword">use</span> <span class="constructor constant type">std</span><span class="punctuation_delimiter">::</span><span class="constructor constant type">arch</span><span class="punctuation_delimiter">::</span><span class="constructor constant">x86_64</span><span class="punctuation_delimiter">::</span><span class="operator">*</span><span class="punctuation_delimiter">;</span>
    
    <span class="keyword">let</span> <span class="constructor constant">threshold_vec</span> = <span class="keyword">unsafe</span> <span class="punctuation_bracket">{</span> <span class="constructor constant function">_mm256_set1_epi8</span><span class="punctuation_bracket">(</span><span class="constructor constant">threshold</span> <span class="keyword">as</span> <span class="type_builtin">i8</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span>
    <span class="keyword">let</span> <span class="constructor constant">ones</span> = <span class="keyword">unsafe</span> <span class="punctuation_bracket">{</span> <span class="constructor constant function">_mm256_set1_epi8</span><span class="punctuation_bracket">(</span>-<span class="constant_builtin">1</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">}</span><span class="punctuation_delimiter">;</span> <span class="comment">// All 1s</span>
    
    <span class="comment">// Process 32 bytes at a time</span>
    <span class="keyword">for</span> <span class="constructor constant">chunk</span> <span class="keyword">in</span> <span class="constructor constant">image</span><span class="punctuation_delimiter">.</span><span class="property function_method">chunks_exact_mut</span><span class="punctuation_bracket">(</span><span class="constant_builtin">32</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="keyword">unsafe</span> <span class="punctuation_bracket">{</span>
            <span class="keyword">let</span> <span class="constructor constant">pixels</span> = <span class="constructor constant function">_mm256_loadu_si256</span><span class="punctuation_bracket">(</span><span class="constructor constant">chunk</span><span class="punctuation_delimiter">.</span><span class="property function_method">as_ptr</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="keyword">as</span> <span class="operator">*</span><span class="keyword">const</span> <span class="type">__m256i</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="keyword">let</span> <span class="constructor constant">mask</span> = <span class="constructor constant function">_mm256_cmpgt_epi8</span><span class="punctuation_bracket">(</span><span class="constructor constant">pixels</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">threshold_vec</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="keyword">let</span> <span class="constructor constant">result</span> = <span class="constructor constant function">_mm256_and_si256</span><span class="punctuation_bracket">(</span><span class="constructor constant">mask</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">ones</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
            <span class="constructor constant function">_mm256_storeu_si256</span><span class="punctuation_bracket">(</span><span class="constructor constant">chunk</span><span class="punctuation_delimiter">.</span><span class="property function_method">as_mut_ptr</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="keyword">as</span> <span class="operator">*</span><span class="keyword">mut</span> <span class="type">__m256i</span><span class="punctuation_delimiter">,</span> <span class="constructor constant">result</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">;</span>
        <span class="punctuation_bracket">}</span>
    <span class="punctuation_bracket">}</span>
    
    <span class="comment">// Handle remaining bytes</span>
    <span class="keyword">for</span> <span class="constructor constant">pixel</span> <span class="keyword">in</span> <span class="constructor constant">image</span><span class="punctuation_delimiter">.</span><span class="property function_method">chunks_exact_mut</span><span class="punctuation_bracket">(</span><span class="constant_builtin">32</span><span class="punctuation_bracket">)</span><span class="punctuation_delimiter">.</span><span class="property function_method">into_remainder</span><span class="punctuation_bracket">(</span><span class="punctuation_bracket">)</span> <span class="punctuation_bracket">{</span>
        <span class="operator">*</span><span class="constructor constant">pixel</span> = <span class="punctuation_bracket">(</span><span class="punctuation_bracket">(</span><span class="operator">*</span><span class="constructor constant">pixel</span> &gt; <span class="constructor constant">threshold</span><span class="punctuation_bracket">)</span> <span class="keyword">as</span> <span class="type_builtin">u8</span><span class="punctuation_bracket">)</span> <span class="operator">*</span> <span class="constant_builtin">255</span><span class="punctuation_delimiter">;</span>
    <span class="punctuation_bracket">}</span>
<span class="punctuation_bracket">}</span>
</code></pre>
<h2>Best Practices and Guidelines</h2><h3>When to Optimize</h3><ol><li><strong>Profile first</strong>: Always measure before optimizing</li><li><strong>Focus on hot paths</strong>: Optimize the 10% of code that runs 90% of the time</li><li><strong>Consider readability</strong>: Micro-optimizations should be well-documented</li></ol><h3>Common Pitfalls</h3><ol><li><strong>Premature optimization</strong>: Don’t sacrifice code clarity for unmeasured gains</li><li><strong>Over-optimization</strong>: Sometimes the compiler already generates optimal code</li><li><strong>Ignoring context</strong>: Optimizations that work in one scenario may hurt in another</li></ol><h3>Tools for Continuous Monitoring</h3><ul><li><strong>Criterion</strong>: For micro-benchmarks and regression detection</li><li><strong>Flamegraph</strong>: For identifying hot spots visually</li><li><strong>Valgrind/Cachegrind</strong>: For detailed cache analysis</li><li><strong>Intel VTune</strong>: For comprehensive CPU profiling (Intel CPUs)</li></ul><h2>Conclusion</h2><p>Optimizing branch prediction and cache performance in Rust requires a combination of understanding hardware behavior, careful code design, and rigorous measurement. The techniques covered in this post can lead to significant performance improvements, but remember that the most effective optimization is often the one that’s measured and validated.</p><p>Start with profiling to identify bottlenecks, apply the appropriate techniques, and always measure the results. Modern CPUs are incredibly sophisticated, and sometimes the best optimization is letting the hardware do what it does best while staying out of its way.</p><p>The key is finding the balance between writing idiomatic Rust code and leveraging low-level optimizations where they truly matter. With careful application of these techniques, you can write Rust code that not only compiles to safe, fast machine code but also works harmoniously with modern CPU architectures to deliver exceptional performance.</p></div>
  <div id="prev-next">
    <div></div>
    <div></div>
  </div>

    <footer>
      <hr>
      <p>jeroen</p>
    </footer>
  </body>
</html>